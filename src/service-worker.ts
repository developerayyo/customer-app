/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

// Claim clients immediately
clientsClaim();

// Precache all assets generated by your build process
// Their URLs are injected into the manifest variable below
// This variable must be present somewhere in your service worker file
// @ts-ignore
const manifest = self.__WB_MANIFEST;
precacheAndRoute(manifest);

// Set up App Shell-style routing
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html
  ({ url }: { url: URL }) => {
    // If this is a URL that starts with /api, it's for the API
    if (url.pathname.startsWith('/api')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler
    return true;
  },
  createHandlerBoundToURL('/index.html')
);

// Cache the API responses
registerRoute(
  ({ url }) => url.pathname.startsWith('/api'),
  new StaleWhileRevalidate({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60, // 1 hour
      }),
    ],
  })
);

// Cache images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache static assets: CSS/JS
registerRoute(
  ({ request }) => request.destination === 'style' || request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({ maxEntries: 80, maxAgeSeconds: 7 * 24 * 60 * 60 }),
    ],
  })
);

// Cache fonts (Google Fonts or local)
registerRoute(
  ({ request, url }) => request.destination === 'font' || url.origin.includes('fonts.googleapis.com') || url.origin.includes('fonts.gstatic.com'),
  new CacheFirst({
    cacheName: 'font-cache',
    plugins: [
      new ExpirationPlugin({ maxEntries: 20, maxAgeSeconds: 60 * 24 * 60 * 60 }) // 60 days
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event: ExtendableMessageEvent) => {
  if ((event as any).data && (event as any).data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Background sync for offline form submissions
self.addEventListener('sync', (event: any) => {
  if (event.tag === 'order-sync') {
    event.waitUntil(syncOrders());
  } else if (event.tag === 'feedback-sync') {
    event.waitUntil(syncFeedback());
  }
});

async function syncOrders() {
  try {
    const pendingOrdersStr = await self.caches.match(new Request('/pending-orders'));
    if (!pendingOrdersStr) return;
    
    const pendingOrders = JSON.parse(await pendingOrdersStr.text());
    
  for (const order of pendingOrders) {
      await fetch('/api/resource/Sales Order', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ data: order }),
      });
    }
    
    // Clear pending orders after successful sync
    const cache = await self.caches.open('pending-data');
    await cache.delete('/pending-orders');
  } catch (error) {
    console.error('Failed to sync orders:', error);
  }
}

async function syncFeedback() {
  try {
    const pendingFeedbackStr = await self.caches.match(new Request('/pending-feedback'));
    if (!pendingFeedbackStr) return;
    
    const pendingFeedback = JSON.parse(await pendingFeedbackStr.text());
    
    for (const feedback of pendingFeedback) {
      await fetch('/api/resource/Customer Feedback', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(feedback),
      });
    }
    
    // Clear pending feedback after successful sync
    const cache = await self.caches.open('pending-data');
    await cache.delete('/pending-feedback');
  } catch (error) {
    console.error('Failed to sync feedback:', error);
  }
}

// Handle push notifications
self.addEventListener('push', (event: PushEvent) => {
  const data = event.data?.json() ?? {};
  const title = data.title || 'New Notification';
  const options = {
    body: data.body || 'You have a new notification',
    icon: '/logo_512x512.png',
    badge: '/logo.png',
    data: {
      url: data.url || '/',
    },
  };

  event.waitUntil(
    self.registration.showNotification(title, options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event: NotificationEvent) => {
  event.notification.close();
  
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clientList) => {
      const url = (event.notification as any).data?.url || '/';
      
      // If a window is already open, focus it
      for (const client of clientList) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      
      // Otherwise open a new window
      return self.clients.openWindow(url);
    })
  );
});

// Handle share target POST submissions
self.addEventListener('fetch', (event: FetchEvent) => {
  const url = new URL(event.request.url);
  if (event.request.method === 'POST' && url.pathname === '/share-target') {
    event.respondWith((async () => {
      try {
        const formData = await (event.request.clone() as Request).formData();
        const title = formData.get('title') as string | null;
        const text = formData.get('text') as string | null;
        const link = formData.get('url') as string | null;
        const files = formData.getAll('files') as File[];

        // Persist shared payload to cache for the app page to consume
        const cache = await caches.open('shared-data');
        await cache.put('/shared-payload', new Response(JSON.stringify({ title, text, link, files: files.length }))); // files cannot be serialized, pass count

        // Focus existing client or open Share page
        const allClients = await self.clients.matchAll({ type: 'window', includeUncontrolled: true });
        const targetUrl = '/share-target';
        for (const client of allClients) {
          if (client.url.includes(targetUrl)) {
            client.focus();
            return Response.redirect(targetUrl, 303);
          }
        }
        await self.clients.openWindow(targetUrl);
        return new Response('', { status: 201 });
      } catch (err) {
        console.error('Share target handling failed:', err);
        return new Response('Share failed', { status: 500 });
      }
    })());
  }
});

// Periodic background sync for dashboard data
self.addEventListener('periodicsync', (event: any) => {
  if (event.tag === 'dashboard-sync') {
    event.waitUntil((async () => {
      try {
        await fetch('/api/method/ping');
        // Prime caches for key API endpoints
        await caches.open('api-cache');
        // Optionally hit endpoints to refresh server-side cache
        await fetch('/api/resource/Sales Order?limit=10');
        await fetch('/api/resource/Sales Invoice?limit=10');
      } catch (e) {
        console.warn('Periodic sync failed:', e);
      }
    })());
  }
});